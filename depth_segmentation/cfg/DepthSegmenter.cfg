#!/usr/bin/env python
PACKAGE = "depth_segmentation"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

# Surface normal estimation parameters.
surface_normal = gen.add_group("surface_normal")
surface_normal.add("normals_method", int_t, 0,
                   "Normal estimation Method (0: Fals, 1: Linemod, 2: Sri, 3: "
                   "Own)",
                   3, 0, 3)
surface_normal.add("normals_distance_factor_threshold", double_t, 0,
                   "Maximal euclidean distance factor (depending on the "
                   "midpoint distance to the camera) for a point to be "
                   "considered in the neighborhood.",
                   0.01, 0.0, 1.0)
surface_normal.add("normals_window_size", int_t, 0,
                   "The window size for the neighborhood.", 11, 3, 31)
surface_normal.add("normals_display", bool_t, 0,
                   "Display the estimated normals.", False)

# Maximum distance parameters.
max_distance = gen.add_group("max_distance")
max_distance.add("max_distance_window_size", int_t, 0,
                 "The window size for the neighborhood.", 3, 1, 9)
max_distance.add("max_distance_exclude_nan_as_max_distance", bool_t, 0,
                 "Exclude nans as max distances.", False)
max_distance.add("max_distance_ignore_nan_coordinates", bool_t, 0,
                 "Exclude all values that have at least one nan in them for "
                 "the max distance calculation.", False)
max_distance.add("max_distance_use_threshold", bool_t, 0,
                 "Enable a threshold value for the max distance calculation.",
                 True)
max_distance.add("max_distance_noise_thresholding_factor", double_t, 0,
                 "Noise thresholding factor, depending on the midpoint "
                 "distance.", 6.0, 0.0, 20.0)
max_distance.add("max_distance_sensor_noise_param_1", double_t, 0,
                 "Noise model first order parameter.", 0.0012, 0.0, 1.0)
max_distance.add("max_distance_sensor_noise_param_2", double_t, 0,
                 "Noise model second order parameter.", 0.0019, 0.0, 1.0)
max_distance.add("max_distance_sensor_noise_param_3", double_t, 0,
                 "Noise model third order parameter.", 0.0001, 0.0, 1.0)
max_distance.add("max_distance_sensor_min_distance", double_t, 0,
                 "Minimal sensor distance.", 0.2, 0.0, 1.0)
max_distance.add("max_distance_display", bool_t, 0,
                 "Display the max distance map.", False)

# Min convexity map parameters.
min_convexity = gen.add_group("min_convexity")
min_convexity.add("min_convexity_window_size", int_t, 0,
                  "The window size for the neighborhood.", 5, 1, 9)
min_convexity.add("min_convexity_use_morphological_opening", bool_t, 0,
                  "Enable the morphological opening filter.", True)
min_convexity.add("min_convexity_morphological_opening_size", int_t, 0,
                  "Pixel width of the morphological opening fitler.", 1, 1, 9)
min_convexity.add("min_convexity_use_threshold", bool_t, 0,
                  "Enable a threshold value for the min convexity calculation.",
                  True)
min_convexity.add("min_convexity_step_size", int_t, 0,
                  "The pixel step size of the min convexity filter.", 1, 1, 9)
min_convexity.add("min_convexity_threshold", double_t, 0,
                  "The threshold of what is still convex.", 0.95, 0.0, 1.0)
min_convexity.add("min_convexity_display", bool_t, 0,
                  "Display the min convexity map.", False)

# Final edge map parameters.
final_edge = gen.add_group("final_edge")
final_edge.add("final_edge_use_morphological_opening", bool_t, 0,
               "Enable the morphological opening filter.", True)
final_edge.add("final_edge_morphological_opening_size", int_t, 0,
               "The window size for the neighborhood.", 1, 1, 9)
final_edge.add("final_edge_use_morphological_closing", bool_t, 0,
               "Enable the morphological closing filter.", True)
final_edge.add("final_edge_morphological_closing_size", int_t, 0,
               "The window size for the neighborhood.", 1, 1, 9)
final_edge.add("final_edge_display", bool_t, 0,
               "Display the final edge map.", False)

# Label map parameters.
label = gen.add_group("label")
label.add("label_display", bool_t, 0, "Display the label map.", True)

exit(gen.generate(PACKAGE, "depth_segmentation", "DepthSegmenter"))
